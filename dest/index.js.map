{"version":3,"sources":["../src/index.js"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["function isReactClass(type) {\n  return type.prototype && type.prototype.isReactComponent;\n}\n\nclass CompositeComponent {\n  constructor(element) {\n    this.currentElement = element;\n    // internal instance of rendered component, see mount();\n    // eg: const App = ()=> <Foo />; \n    // then appInternalInstance.renderedComponent will be fooInternalInstance\n    this.renderedComponent = null;\n    this.publicInstance = null;\n  }\n  getPublicInstance() {\n    return this.publicInstance\n  }\n  getHostNode() {\n    // recursively get host node\n    return this.renderedComponent.getHostNode();\n  }\n  receive(nextElement) {\n    const { type, props: nextProps } = nextElement;\n\n    // save previous renderedComponent and element\n    const previousComponent = this.renderedComponent;\n    const previousRenderedElement = previousComponent.currentElement;\n\n    // get next rendered element\n    let nextRenderedElement;\n    if (isReactClass(type)) {\n      const { componentWillUpdate } = this.publicInstance;\n\n      if (typeof componentWillUpdate === 'function') {\n        componentWillUpdate.call(this.publicInstance, this.currentElement.props);\n      }\n\n      this.publicInstance.props = nextProps;\n      nextRenderedElement = this.publicInstance.render();\n    } else {\n      nextRenderedElement = type(nextProps);\n    }\n\n    // next element type might be different from previous\n    // eg: const App = ({areYouOk})=> areYouOk ? <Congratulations /> : <GoodLuck />\n    // if type not changed, just call receive on previous renderedComponent\n    if (nextRenderedElement.type === previousRenderedElement.type) {\n      previousComponent.receive(nextRenderedElement)\n    } else { // otherwise, re-create renderedComponent instance \n      this.renderedComponent = instantiateComponent(nextRenderedElement);\n\n      // get dom node of rendered tree\n      const nextHostNode = this.renderedComponent.mount();\n\n      const previousHostNode = previousComponent.getHostNode();\n\n      previousComponent.unmount();\n\n      // replace dom node\n      previousHostNode.parentNode.replaceChild(nextHostNode, previousHostNode)\n    }\n  }\n  mount() {\n    const { type, props } = this.currentElement;\n    let renderedElement;\n\n    // es6 class\n    if (isReactClass(type)) {\n      // create public instance\n      this.publicInstance = new type(props);\n      // record internal instance\n      this.publicInstance._reactInternalInstance = this;\n\n      const { componentWillMount } = this.publicInstance;\n\n      // call componentWillMount life-cycle method if exist\n      if (typeof componentWillMount === 'function') {\n        componentWillMount.call(this.publicInstance);\n      }\n\n      // get renderedElement by call render method\n      renderedElement = this.publicInstance.render();\n    } else { // function component\n      renderedElement = type(props);\n    }\n\n    // * recursivly instatiate renderedElement and mount\n    // since it could only be DOM node in the leaf of component tree\n    // so the return value of recursive mount method will be DOM node.\n    this.renderedComponent = instantiateComponent(renderedElement);\n    return this.renderedComponent.mount()\n  }\n  unmount() {\n    // call componentWillUnmount life-cycle if exist\n    if (this.publicInstance && this.publicInstance.componentWillUnmount) {\n      this.publicInstance.componentWillUnmount();\n    }\n\n    this.renderedComponent.unmount();\n  }\n}\n\nclass DOMComponent {\n  constructor(element) {\n    this.currentElement = element;\n    this.node = null;\n    this.renderedChildren = [];\n  }\n  getPublicInstance() {\n    return this.node;\n  }\n  getHostNode() {\n    return this.node;\n  }\n  receive(nextElement) {\n    const { props: nextProps } = nextElement;\n    const { props: previousProps } = this.currentElement;\n    const node = this.node;\n\n    this.currentElement = nextElement;\n\n    // remove old attrs\n    Object.keys(previousProps).forEach(function(prop) {\n      if (prop !== 'children' && !nextProps.hasOwnProperty(prop)) {\n        node.removeAttribute(prop)\n      }\n    });\n\n    // set next attrs\n    Object.keys(nextProps).forEach(function(prop) {\n      if (prop !== 'children' && previousProps.hasOwnProperty(prop)) {\n        node.setAttribute(prop, nextProps[prop])\n      }\n    });\n\n    const preChildrenElements = previousProps.children;\n    const nextChildrenElements = nextProps.children;\n\n    const previousRenderedChildren = this.renderedChildren\n    const nextRenderedChildren = []\n\n    nextChildrenElements.forEach((nextChildElement, index) => {\n      const preChildElement = preChildrenElements[index];\n\n      // replace child node if previous child is text node or type not match\n      const needReplace = checkTextNodeElement(preChildElement) || (nextChildElement.type !== preChildElement.type);\n      if (!preChildElement) {//append new if previous child not exist\n        const nextChildComponent = instantiateComponent(nextChildElement);\n        nextRenderedChildren.push(nextChildComponent);\n        node.appendChild(nextChildComponent.mount());\n      } else if (needReplace) {// do replace if need\n        const nextChildComponent = instantiateComponent(nextChildElement);\n        nextRenderedChildren.push(nextChildComponent);\n        node.replaceChild(nextChildComponent.mount(), previousRenderedChildren[index].getHostNode());\n      } else { // update if child type is not text node and not changed \n        const previousRenderedComponent = previousRenderedChildren[index];\n        nextRenderedChildren.push(previousRenderedComponent);\n\n        // call receive on renderedComponent to update recursively\n        previousRenderedComponent.receive(nextChildElement);\n      }\n    });\n\n    // unmount & remove extra child that don't exist\n    preChildrenElements.forEach((previousChildElement, index) => {\n      if (!nextChildrenElements[index]) {\n        const previousRenderedComponent = previousRenderedChildren[index];\n        previousRenderedComponent.unmount();\n\n        node.removeChild(previousRenderedComponent.getHostNode());\n      }\n    });\n\n    this.renderedChildren = nextRenderedChildren;\n\n  }\n  mount() {\n    const element = this.currentElement;\n    const isTextNodeElement = checkTextNodeElement(element);\n    let node;\n\n    if (isTextNodeElement) {\n      node = document.createTextNode(element);\n    } else {\n      const { type, props : { children, ...attributes } } = element;\n\n      // create dom node by tag\n      node = document.createElement(type);\n\n      // set attributes of dom node\n      Object.keys(attributes).forEach(k => {\n        node.setAttribute(k, attributes[k]);\n      });\n\n      // tag without children like <input/> is not supported yet\n      // recursively create instance for childrens\n      // CompositeComponent have only one child -- the component it **renders**: const Parent = ()=> <Child />\n      // but HostComponent(DOMComponent) can have multiple children -- the components it **contains**: const App = ()=> <div><A/><B/><C/></div>\n      children.forEach(child => {\n        const childComponent = instantiateComponent(child);\n        this.renderedChildren.push(childComponent)\n\n        // call mount to get dom node of child component recursively then append as child node\n        node.appendChild(childComponent.mount());\n      });\n    }\n\n    this.node = node;\n    return this.node;\n  }\n  unmount() {\n    this.renderedChildren.forEach((childComponent) => {\n      childComponent.unmount()\n    })\n\n  }\n}\n\nfunction checkTextNodeElement(element) {\n  return ['string', 'number'].indexOf(typeof element) !== -1;\n}\n\nfunction isCompositeElement(element) {\n  return typeof element === 'object' && typeof element.type === 'function';\n}\n\n// create internal instance of element\nfunction instantiateComponent(element) {\n  return isCompositeElement(element)\n    ? new CompositeComponent(element)\n    : new DOMComponent(element);\n}\n\nwindow.React = {\n  Component: class Component {\n    constructor(props) {\n      this.props = props;\n    }\n    setState(nextState){\n      const reactComponent = this._reactInternalInstance;\n\n      this.state = Object.assign({}, this.state, nextState);\n\n      if (reactComponent) {\n        reactComponent.renderedComponent.receive(this.render())\n      }\n    }\n    isReactComponent() {\n      return true\n    }\n  },\n  createElement(type, props, ...children) {\n    const finalProps = {...props, children};\n    return {\n      type,\n      props: finalProps\n    }\n  }\n};\n\nwindow.ReactDOM = {\n  render(element, container) {\n    // Update if already mounted\n    if (container.firstChild) {\n      const instance = container.firstChild._internalInstance;\n      instance.receive(element);\n      return;\n    }\n\n    // create component internal instance\n    const rootComponent = instantiateComponent(element);\n    \n    // create dom node tree\n    const node = rootComponent.mount();\n\n    // recored internalInstance on node so we can check & update the dom tree on re-render\n    node._internalInstance = rootComponent;\n\n    // append the dom tree to container\n    container.appendChild(node);\n\n    // get public instance see CompositeComponent & DOMComponent\n    return rootComponent.getPublicInstance();\n  },\n  unmountComponentAtNode(container) {\n    const instance = container.firstChild._internalInstance;\n    instance.unmount();\n    container.innerHTML = '';\n  }\n};\n"]}